// Code generated by protoc-gen-go.
// source: zebra.proto
// DO NOT EDIT!

/*
Package zebra is a generated protocol buffer package.

It is generated from these files:
	zebra.proto

It has these top-level messages:
	IPv4
	PrefixIPv4
	NexthopIPv4
	IPv6
	PrefixIPv6
	NexthopIPv6
	RouteIPv4
	RouteIPv4Response
	RouteIPv6
	RouteIPv6Response
*/
package zebra

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RouteType int32

const (
	RouteType_RIB_UNKNOWN   RouteType = 0
	RouteType_RIB_KERNEL    RouteType = 1
	RouteType_RIB_CONNECTED RouteType = 2
	RouteType_RIB_STATIC    RouteType = 3
	RouteType_RIB_RIP       RouteType = 4
	RouteType_RIB_RIPNG     RouteType = 5
	RouteType_RIB_OSPF      RouteType = 6
	RouteType_RIB_OSPF6     RouteType = 7
	RouteType_RIB_BGP       RouteType = 8
	RouteType_RIB_ISIS      RouteType = 9
)

var RouteType_name = map[int32]string{
	0: "RIB_UNKNOWN",
	1: "RIB_KERNEL",
	2: "RIB_CONNECTED",
	3: "RIB_STATIC",
	4: "RIB_RIP",
	5: "RIB_RIPNG",
	6: "RIB_OSPF",
	7: "RIB_OSPF6",
	8: "RIB_BGP",
	9: "RIB_ISIS",
}
var RouteType_value = map[string]int32{
	"RIB_UNKNOWN":   0,
	"RIB_KERNEL":    1,
	"RIB_CONNECTED": 2,
	"RIB_STATIC":    3,
	"RIB_RIP":       4,
	"RIB_RIPNG":     5,
	"RIB_OSPF":      6,
	"RIB_OSPF6":     7,
	"RIB_BGP":       8,
	"RIB_ISIS":      9,
}

func (x RouteType) String() string {
	return proto.EnumName(RouteType_name, int32(x))
}
func (RouteType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type RouteSubType int32

const (
	RouteSubType_RIB_SUB_OSPF_IA         RouteSubType = 0
	RouteSubType_RIB_SUB_OSPF_NSSA_1     RouteSubType = 1
	RouteSubType_RIB_SUB_OSPF_NSSA_2     RouteSubType = 2
	RouteSubType_RIB_SUB_OSPF_EXTERNAL_1 RouteSubType = 3
	RouteSubType_RIB_SUB_OSPF_EXTERNAL_2 RouteSubType = 4
	RouteSubType_RIB_SUB_BGP_IBGP        RouteSubType = 5
	RouteSubType_RIB_SUB_BGP_EBGP        RouteSubType = 6
	RouteSubType_RIB_SUB_BGP_CONFED      RouteSubType = 7
	RouteSubType_RIB_SUB_ISIS_L1         RouteSubType = 8
	RouteSubType_RIB_SUB_ISIS_L2         RouteSubType = 9
	RouteSubType_RIB_SUB_ISIS_IA         RouteSubType = 10
)

var RouteSubType_name = map[int32]string{
	0:  "RIB_SUB_OSPF_IA",
	1:  "RIB_SUB_OSPF_NSSA_1",
	2:  "RIB_SUB_OSPF_NSSA_2",
	3:  "RIB_SUB_OSPF_EXTERNAL_1",
	4:  "RIB_SUB_OSPF_EXTERNAL_2",
	5:  "RIB_SUB_BGP_IBGP",
	6:  "RIB_SUB_BGP_EBGP",
	7:  "RIB_SUB_BGP_CONFED",
	8:  "RIB_SUB_ISIS_L1",
	9:  "RIB_SUB_ISIS_L2",
	10: "RIB_SUB_ISIS_IA",
}
var RouteSubType_value = map[string]int32{
	"RIB_SUB_OSPF_IA":         0,
	"RIB_SUB_OSPF_NSSA_1":     1,
	"RIB_SUB_OSPF_NSSA_2":     2,
	"RIB_SUB_OSPF_EXTERNAL_1": 3,
	"RIB_SUB_OSPF_EXTERNAL_2": 4,
	"RIB_SUB_BGP_IBGP":        5,
	"RIB_SUB_BGP_EBGP":        6,
	"RIB_SUB_BGP_CONFED":      7,
	"RIB_SUB_ISIS_L1":         8,
	"RIB_SUB_ISIS_L2":         9,
	"RIB_SUB_ISIS_IA":         10,
}

func (x RouteSubType) String() string {
	return proto.EnumName(RouteSubType_name, int32(x))
}
func (RouteSubType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type IPv4 struct {
	SAddr uint32 `protobuf:"varint,1,opt,name=s_addr,json=sAddr" json:"s_addr,omitempty"`
}

func (m *IPv4) Reset()                    { *m = IPv4{} }
func (m *IPv4) String() string            { return proto.CompactTextString(m) }
func (*IPv4) ProtoMessage()               {}
func (*IPv4) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *IPv4) GetSAddr() uint32 {
	if m != nil {
		return m.SAddr
	}
	return 0
}

type PrefixIPv4 struct {
	Addr   *IPv4  `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	Length uint32 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
}

func (m *PrefixIPv4) Reset()                    { *m = PrefixIPv4{} }
func (m *PrefixIPv4) String() string            { return proto.CompactTextString(m) }
func (*PrefixIPv4) ProtoMessage()               {}
func (*PrefixIPv4) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PrefixIPv4) GetAddr() *IPv4 {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *PrefixIPv4) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

type NexthopIPv4 struct {
	Addr    *IPv4  `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	Ifindex uint32 `protobuf:"varint,2,opt,name=ifindex" json:"ifindex,omitempty"`
}

func (m *NexthopIPv4) Reset()                    { *m = NexthopIPv4{} }
func (m *NexthopIPv4) String() string            { return proto.CompactTextString(m) }
func (*NexthopIPv4) ProtoMessage()               {}
func (*NexthopIPv4) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *NexthopIPv4) GetAddr() *IPv4 {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *NexthopIPv4) GetIfindex() uint32 {
	if m != nil {
		return m.Ifindex
	}
	return 0
}

type IPv6 struct {
	S6Addr1 uint32 `protobuf:"varint,1,opt,name=s6_addr1,json=s6Addr1" json:"s6_addr1,omitempty"`
	S6Addr2 uint32 `protobuf:"varint,2,opt,name=s6_addr2,json=s6Addr2" json:"s6_addr2,omitempty"`
	S6Addr3 uint32 `protobuf:"varint,3,opt,name=s6_addr3,json=s6Addr3" json:"s6_addr3,omitempty"`
	S6Addr4 uint32 `protobuf:"varint,4,opt,name=s6_addr4,json=s6Addr4" json:"s6_addr4,omitempty"`
}

func (m *IPv6) Reset()                    { *m = IPv6{} }
func (m *IPv6) String() string            { return proto.CompactTextString(m) }
func (*IPv6) ProtoMessage()               {}
func (*IPv6) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *IPv6) GetS6Addr1() uint32 {
	if m != nil {
		return m.S6Addr1
	}
	return 0
}

func (m *IPv6) GetS6Addr2() uint32 {
	if m != nil {
		return m.S6Addr2
	}
	return 0
}

func (m *IPv6) GetS6Addr3() uint32 {
	if m != nil {
		return m.S6Addr3
	}
	return 0
}

func (m *IPv6) GetS6Addr4() uint32 {
	if m != nil {
		return m.S6Addr4
	}
	return 0
}

type PrefixIPv6 struct {
	Addr   *IPv6  `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	Length uint32 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
}

func (m *PrefixIPv6) Reset()                    { *m = PrefixIPv6{} }
func (m *PrefixIPv6) String() string            { return proto.CompactTextString(m) }
func (*PrefixIPv6) ProtoMessage()               {}
func (*PrefixIPv6) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PrefixIPv6) GetAddr() *IPv6 {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *PrefixIPv6) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

type NexthopIPv6 struct {
	Addr    *IPv6  `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	Ifindex uint32 `protobuf:"varint,2,opt,name=ifindex" json:"ifindex,omitempty"`
}

func (m *NexthopIPv6) Reset()                    { *m = NexthopIPv6{} }
func (m *NexthopIPv6) String() string            { return proto.CompactTextString(m) }
func (*NexthopIPv6) ProtoMessage()               {}
func (*NexthopIPv6) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NexthopIPv6) GetAddr() *IPv6 {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *NexthopIPv6) GetIfindex() uint32 {
	if m != nil {
		return m.Ifindex
	}
	return 0
}

type RouteIPv4 struct {
	Type     RouteType      `protobuf:"varint,1,opt,name=type,enum=zebra.RouteType" json:"type,omitempty"`
	SubType  RouteSubType   `protobuf:"varint,2,opt,name=sub_type,json=subType,enum=zebra.RouteSubType" json:"sub_type,omitempty"`
	Prefix   *PrefixIPv4    `protobuf:"bytes,3,opt,name=prefix" json:"prefix,omitempty"`
	Distance uint32         `protobuf:"varint,4,opt,name=distance" json:"distance,omitempty"`
	Metric   uint32         `protobuf:"varint,5,opt,name=metric" json:"metric,omitempty"`
	Nexthops []*NexthopIPv4 `protobuf:"bytes,6,rep,name=nexthops" json:"nexthops,omitempty"`
}

func (m *RouteIPv4) Reset()                    { *m = RouteIPv4{} }
func (m *RouteIPv4) String() string            { return proto.CompactTextString(m) }
func (*RouteIPv4) ProtoMessage()               {}
func (*RouteIPv4) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *RouteIPv4) GetType() RouteType {
	if m != nil {
		return m.Type
	}
	return RouteType_RIB_UNKNOWN
}

func (m *RouteIPv4) GetSubType() RouteSubType {
	if m != nil {
		return m.SubType
	}
	return RouteSubType_RIB_SUB_OSPF_IA
}

func (m *RouteIPv4) GetPrefix() *PrefixIPv4 {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *RouteIPv4) GetDistance() uint32 {
	if m != nil {
		return m.Distance
	}
	return 0
}

func (m *RouteIPv4) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *RouteIPv4) GetNexthops() []*NexthopIPv4 {
	if m != nil {
		return m.Nexthops
	}
	return nil
}

type RouteIPv4Response struct {
}

func (m *RouteIPv4Response) Reset()                    { *m = RouteIPv4Response{} }
func (m *RouteIPv4Response) String() string            { return proto.CompactTextString(m) }
func (*RouteIPv4Response) ProtoMessage()               {}
func (*RouteIPv4Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type RouteIPv6 struct {
	Type     RouteType      `protobuf:"varint,1,opt,name=type,enum=zebra.RouteType" json:"type,omitempty"`
	SubType  RouteSubType   `protobuf:"varint,2,opt,name=sub_type,json=subType,enum=zebra.RouteSubType" json:"sub_type,omitempty"`
	Prefix   *PrefixIPv6    `protobuf:"bytes,3,opt,name=prefix" json:"prefix,omitempty"`
	Distance uint32         `protobuf:"varint,4,opt,name=distance" json:"distance,omitempty"`
	Metric   uint32         `protobuf:"varint,5,opt,name=metric" json:"metric,omitempty"`
	Nexthops []*NexthopIPv6 `protobuf:"bytes,6,rep,name=nexthops" json:"nexthops,omitempty"`
}

func (m *RouteIPv6) Reset()                    { *m = RouteIPv6{} }
func (m *RouteIPv6) String() string            { return proto.CompactTextString(m) }
func (*RouteIPv6) ProtoMessage()               {}
func (*RouteIPv6) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RouteIPv6) GetType() RouteType {
	if m != nil {
		return m.Type
	}
	return RouteType_RIB_UNKNOWN
}

func (m *RouteIPv6) GetSubType() RouteSubType {
	if m != nil {
		return m.SubType
	}
	return RouteSubType_RIB_SUB_OSPF_IA
}

func (m *RouteIPv6) GetPrefix() *PrefixIPv6 {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *RouteIPv6) GetDistance() uint32 {
	if m != nil {
		return m.Distance
	}
	return 0
}

func (m *RouteIPv6) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *RouteIPv6) GetNexthops() []*NexthopIPv6 {
	if m != nil {
		return m.Nexthops
	}
	return nil
}

type RouteIPv6Response struct {
}

func (m *RouteIPv6Response) Reset()                    { *m = RouteIPv6Response{} }
func (m *RouteIPv6Response) String() string            { return proto.CompactTextString(m) }
func (*RouteIPv6Response) ProtoMessage()               {}
func (*RouteIPv6Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func init() {
	proto.RegisterType((*IPv4)(nil), "zebra.IPv4")
	proto.RegisterType((*PrefixIPv4)(nil), "zebra.PrefixIPv4")
	proto.RegisterType((*NexthopIPv4)(nil), "zebra.NexthopIPv4")
	proto.RegisterType((*IPv6)(nil), "zebra.IPv6")
	proto.RegisterType((*PrefixIPv6)(nil), "zebra.PrefixIPv6")
	proto.RegisterType((*NexthopIPv6)(nil), "zebra.NexthopIPv6")
	proto.RegisterType((*RouteIPv4)(nil), "zebra.RouteIPv4")
	proto.RegisterType((*RouteIPv4Response)(nil), "zebra.RouteIPv4Response")
	proto.RegisterType((*RouteIPv6)(nil), "zebra.RouteIPv6")
	proto.RegisterType((*RouteIPv6Response)(nil), "zebra.RouteIPv6Response")
	proto.RegisterEnum("zebra.RouteType", RouteType_name, RouteType_value)
	proto.RegisterEnum("zebra.RouteSubType", RouteSubType_name, RouteSubType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ZebraApi service

type ZebraApiClient interface {
	RouteIPv4Add(ctx context.Context, in *RouteIPv4, opts ...grpc.CallOption) (*RouteIPv4Response, error)
	RouteIPv4Delete(ctx context.Context, in *RouteIPv4, opts ...grpc.CallOption) (*RouteIPv4Response, error)
	RouteIPv6Add(ctx context.Context, in *RouteIPv6, opts ...grpc.CallOption) (*RouteIPv6Response, error)
	RouteIPv6Delete(ctx context.Context, in *RouteIPv6, opts ...grpc.CallOption) (*RouteIPv6Response, error)
}

type zebraApiClient struct {
	cc *grpc.ClientConn
}

func NewZebraApiClient(cc *grpc.ClientConn) ZebraApiClient {
	return &zebraApiClient{cc}
}

func (c *zebraApiClient) RouteIPv4Add(ctx context.Context, in *RouteIPv4, opts ...grpc.CallOption) (*RouteIPv4Response, error) {
	out := new(RouteIPv4Response)
	err := grpc.Invoke(ctx, "/zebra.ZebraApi/RouteIPv4Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zebraApiClient) RouteIPv4Delete(ctx context.Context, in *RouteIPv4, opts ...grpc.CallOption) (*RouteIPv4Response, error) {
	out := new(RouteIPv4Response)
	err := grpc.Invoke(ctx, "/zebra.ZebraApi/RouteIPv4Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zebraApiClient) RouteIPv6Add(ctx context.Context, in *RouteIPv6, opts ...grpc.CallOption) (*RouteIPv6Response, error) {
	out := new(RouteIPv6Response)
	err := grpc.Invoke(ctx, "/zebra.ZebraApi/RouteIPv6Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zebraApiClient) RouteIPv6Delete(ctx context.Context, in *RouteIPv6, opts ...grpc.CallOption) (*RouteIPv6Response, error) {
	out := new(RouteIPv6Response)
	err := grpc.Invoke(ctx, "/zebra.ZebraApi/RouteIPv6Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ZebraApi service

type ZebraApiServer interface {
	RouteIPv4Add(context.Context, *RouteIPv4) (*RouteIPv4Response, error)
	RouteIPv4Delete(context.Context, *RouteIPv4) (*RouteIPv4Response, error)
	RouteIPv6Add(context.Context, *RouteIPv6) (*RouteIPv6Response, error)
	RouteIPv6Delete(context.Context, *RouteIPv6) (*RouteIPv6Response, error)
}

func RegisterZebraApiServer(s *grpc.Server, srv ZebraApiServer) {
	s.RegisterService(&_ZebraApi_serviceDesc, srv)
}

func _ZebraApi_RouteIPv4Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteIPv4)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZebraApiServer).RouteIPv4Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zebra.ZebraApi/RouteIPv4Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZebraApiServer).RouteIPv4Add(ctx, req.(*RouteIPv4))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZebraApi_RouteIPv4Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteIPv4)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZebraApiServer).RouteIPv4Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zebra.ZebraApi/RouteIPv4Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZebraApiServer).RouteIPv4Delete(ctx, req.(*RouteIPv4))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZebraApi_RouteIPv6Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteIPv6)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZebraApiServer).RouteIPv6Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zebra.ZebraApi/RouteIPv6Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZebraApiServer).RouteIPv6Add(ctx, req.(*RouteIPv6))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZebraApi_RouteIPv6Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteIPv6)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZebraApiServer).RouteIPv6Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zebra.ZebraApi/RouteIPv6Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZebraApiServer).RouteIPv6Delete(ctx, req.(*RouteIPv6))
	}
	return interceptor(ctx, in, info, handler)
}

var _ZebraApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "zebra.ZebraApi",
	HandlerType: (*ZebraApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RouteIPv4Add",
			Handler:    _ZebraApi_RouteIPv4Add_Handler,
		},
		{
			MethodName: "RouteIPv4Delete",
			Handler:    _ZebraApi_RouteIPv4Delete_Handler,
		},
		{
			MethodName: "RouteIPv6Add",
			Handler:    _ZebraApi_RouteIPv6Add_Handler,
		},
		{
			MethodName: "RouteIPv6Delete",
			Handler:    _ZebraApi_RouteIPv6Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "zebra.proto",
}

func init() { proto.RegisterFile("zebra.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 629 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x55, 0xcb, 0x4e, 0xdb, 0x4c,
	0x14, 0x26, 0x8e, 0x63, 0x3b, 0xc7, 0x5c, 0x86, 0xc9, 0xff, 0x83, 0x4b, 0x55, 0x15, 0x45, 0x5d,
	0x50, 0x16, 0x48, 0x31, 0x68, 0x56, 0x95, 0x2a, 0x13, 0x0c, 0xb5, 0x88, 0x1c, 0xcb, 0x0e, 0x6a,
	0xd5, 0x8d, 0x95, 0xe0, 0xa1, 0x58, 0xa2, 0x89, 0x65, 0x3b, 0x55, 0xe8, 0x13, 0x74, 0xdd, 0x57,
	0xe8, 0x0b, 0xf6, 0x11, 0xaa, 0x19, 0x5f, 0xea, 0x90, 0xa4, 0x82, 0x45, 0xd5, 0x5d, 0xbe, 0xcb,
	0x7c, 0xe7, 0xcc, 0x97, 0x89, 0x02, 0xea, 0x57, 0x3a, 0x8a, 0x87, 0x47, 0x51, 0x3c, 0x49, 0x27,
	0xb8, 0xc1, 0x41, 0xfb, 0x05, 0x88, 0x96, 0xf3, 0xe5, 0x04, 0xff, 0x0f, 0x52, 0xe2, 0x0f, 0x83,
	0x20, 0xd6, 0x6a, 0xfb, 0xb5, 0x83, 0x0d, 0xb7, 0x91, 0x18, 0x41, 0x10, 0xb7, 0x4d, 0x00, 0x27,
	0xa6, 0x37, 0xe1, 0x8c, 0x9b, 0x5e, 0x82, 0x58, 0x5a, 0x54, 0x5d, 0x3d, 0xca, 0xf2, 0x98, 0xe4,
	0x72, 0x01, 0xef, 0x80, 0x74, 0x47, 0xc7, 0x9f, 0xd2, 0x5b, 0x4d, 0xe0, 0x29, 0x39, 0x6a, 0xbf,
	0x03, 0xd5, 0xa6, 0xb3, 0xf4, 0x76, 0x12, 0x3d, 0x2e, 0x47, 0x03, 0x39, 0xbc, 0x09, 0xc7, 0x01,
	0x9d, 0xe5, 0x41, 0x05, 0x6c, 0xc7, 0x7c, 0x5f, 0x82, 0x9f, 0x81, 0x92, 0x10, 0xbe, 0x70, 0x27,
	0xdf, 0x58, 0x4e, 0x08, 0x5b, 0xb9, 0x53, 0x91, 0xf4, 0xe2, 0x74, 0x26, 0xe9, 0x15, 0xe9, 0x58,
	0xab, 0x57, 0xa5, 0xe3, 0x8a, 0x74, 0xa2, 0x89, 0x55, 0xe9, 0x64, 0xae, 0x04, 0xb2, 0x7a, 0x79,
	0xf2, 0x94, 0x12, 0x1e, 0x91, 0xb3, 0xba, 0x84, 0x9f, 0x35, 0x68, 0xba, 0x93, 0x69, 0x4a, 0x79,
	0x9b, 0xaf, 0x40, 0x4c, 0xef, 0x23, 0xca, 0x83, 0x36, 0x75, 0x94, 0x07, 0x71, 0x7d, 0x70, 0x1f,
	0x51, 0x97, 0xab, 0xf8, 0x08, 0x94, 0x64, 0x3a, 0xf2, 0xb9, 0x53, 0xe0, 0xce, 0x56, 0xd5, 0xe9,
	0x4d, 0x47, 0xdc, 0x2c, 0x27, 0xd9, 0x07, 0xfc, 0x1a, 0xa4, 0x88, 0x5f, 0x9a, 0x17, 0xa5, 0xea,
	0xdb, 0xb9, 0xfb, 0xf7, 0x73, 0x70, 0x73, 0x03, 0xde, 0x03, 0x25, 0x08, 0x93, 0x74, 0x38, 0xbe,
	0xa6, 0x79, 0x75, 0x25, 0x66, 0x65, 0x7c, 0xa6, 0x69, 0x1c, 0x5e, 0x6b, 0x8d, 0xac, 0x8c, 0x0c,
	0xb1, 0x75, 0xc6, 0x59, 0x19, 0x89, 0x26, 0xed, 0xd7, 0x0f, 0x54, 0x1d, 0xe7, 0x03, 0x2a, 0x0f,
	0xc5, 0x2d, 0x3d, 0xed, 0x16, 0x6c, 0x97, 0x37, 0x76, 0x69, 0x12, 0x4d, 0xc6, 0x09, 0x9d, 0xeb,
	0x81, 0xfc, 0xab, 0x1e, 0xc8, 0x5f, 0xef, 0x81, 0x2c, 0xef, 0x81, 0x14, 0x3d, 0x1c, 0xfe, 0x28,
	0x7a, 0xe0, 0x1b, 0x6f, 0x81, 0xea, 0x5a, 0xa7, 0xfe, 0x95, 0x7d, 0x69, 0xf7, 0xdf, 0xdb, 0x68,
	0x0d, 0x6f, 0x02, 0x30, 0xe2, 0xd2, 0x74, 0x6d, 0xb3, 0x87, 0x6a, 0x78, 0x1b, 0x36, 0x18, 0xee,
	0xf6, 0x6d, 0xdb, 0xec, 0x0e, 0xcc, 0x33, 0x24, 0x14, 0x16, 0x6f, 0x60, 0x0c, 0xac, 0x2e, 0xaa,
	0x63, 0x15, 0x64, 0x86, 0x5d, 0xcb, 0x41, 0x22, 0xde, 0x80, 0x66, 0x0e, 0xec, 0x0b, 0xd4, 0xc0,
	0xeb, 0xa0, 0x30, 0xd8, 0xf7, 0x9c, 0x73, 0x24, 0x15, 0x22, 0x43, 0x04, 0xc9, 0xc5, 0xc1, 0xd3,
	0x0b, 0x07, 0x29, 0x85, 0xd3, 0xf2, 0x2c, 0x0f, 0x35, 0x0f, 0xbf, 0x0b, 0xb0, 0x5e, 0xed, 0x18,
	0xb7, 0x60, 0x8b, 0x0f, 0xbd, 0xca, 0x8e, 0xfb, 0x96, 0x81, 0xd6, 0xf0, 0x2e, 0xb4, 0xe6, 0x48,
	0xdb, 0xf3, 0x0c, 0xbf, 0x83, 0x6a, 0xcb, 0x05, 0x1d, 0x09, 0xf8, 0x39, 0xec, 0xce, 0x09, 0xe6,
	0x87, 0x81, 0xe9, 0xda, 0x46, 0xcf, 0xef, 0xa0, 0xfa, 0x6a, 0x51, 0x47, 0x22, 0xfe, 0x0f, 0x50,
	0x21, 0x9e, 0x5e, 0x38, 0xbe, 0xc5, 0xb6, 0x6e, 0x3c, 0x64, 0x4d, 0xc6, 0x4a, 0x78, 0x07, 0x70,
	0x95, 0xed, 0xf6, 0xed, 0x73, 0xf3, 0x0c, 0xc9, 0xd5, 0x4b, 0xb0, 0x7b, 0xfa, 0xbd, 0x0e, 0x52,
	0x16, 0x49, 0x1d, 0x35, 0x17, 0x48, 0xcb, 0x40, 0xa0, 0x7f, 0x13, 0x40, 0xf9, 0xc8, 0xbe, 0x6f,
	0x23, 0x0a, 0xf1, 0x9b, 0xbc, 0x20, 0xf6, 0xc8, 0x8d, 0x20, 0xc0, 0x73, 0x6f, 0x98, 0x91, 0x7b,
	0xda, 0x43, 0xa6, 0xfc, 0x2d, 0xac, 0xe1, 0xb7, 0xb0, 0x55, 0xd2, 0x67, 0xf4, 0x8e, 0xa6, 0xf4,
	0x89, 0x01, 0x95, 0xf1, 0x64, 0xd9, 0x78, 0xb2, 0x70, 0x9a, 0x2c, 0x1f, 0x4f, 0x56, 0x8c, 0xff,
	0x63, 0xc0, 0x48, 0xe2, 0x7f, 0x4c, 0xc7, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x3f, 0xd4, 0xef,
	0x4f, 0xa7, 0x06, 0x00, 0x00,
}
